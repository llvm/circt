//===- FIRRTLFieldSource.cpp - Field Source Analysis ------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a basic points-to like analysis.
// This analysis tracks any aggregate generated by an operation and maps any
// value derived from indexing of that aggregate back to the source of the
// aggregate along with a path through the type from the source. In parallel,
// this tracks any value which is an alias for a writable storage element, even
// if scalar.  This is sufficient to allow any value used on the LHS of a
// connect to be traced to its source, and to track any value which is a read
// of a storage element back to the source storage element.
//
// There is a redundant walk of the IR going on since flow is walking backwards
// over operations we've already visited.  We need to refactor foldFlow so we
// can build up the flow incrementally.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/FIRRTL/FIRRTLFieldSource.h"

using namespace circt;
using namespace firrtl;


FieldSource::FieldSource(Operation *operation) {
  // Ideally we would build this analysis lazily, but I don't want to make the 
  // paths map mutable, since lookup needs to be constant.

  FModuleOp mod = cast<FModuleOp>(operation);
  mod.walk<mlir::WalkOrder::PreOrder>([&](Operation *op) { 
//    if (isa<ConnectOp, StrictConnectOp>(op))
  for (size_t i = 0; i < op->getNumOperands(); ++i)
      visitValue(op->getOperand(i), [&](Value v, PathNode pn) {paths[v] = pn;});
    });
}

template <typename Fn>
FieldSource::PathNode FieldSource::visitValue(Value v, Fn update) const {
  // Blockargs are never cached, just regenerate.
  if (auto arg = dyn_cast<BlockArgument>(v)) {
    return PathNode{v, 0};
  }
  // Check cache.
  auto ii = paths.find(v);
  if (ii != paths.end())
    return ii->second;
  
  Operation* op = v.getDefiningOp();
  return TypeSwitch<Operation*, PathNode>(op)
  .Case<SubfieldOp>([&](auto subf) {
    auto parent = visitValue(subf.getInput(), update);
    PathNode retval{parent.src, parent.fieldID + subf.getInput().getType().base().getFieldID(subf.getFieldIndex())};
    update(v, retval);
    return retval;
  })
  .template Case<OpenSubfieldOp>([&](auto subf) {
    auto parent = visitValue(subf.getInput(), update);
    PathNode retval{parent.src, parent.fieldID + subf.getInput().getType().getFieldID(subf.getFieldIndex())};
    update(v, retval);
    return retval;
  })
  .template Case<SubindexOp>([&](auto subi) {
    auto parent = visitValue(subi.getInput(), update);
    PathNode retval{parent.src, parent.fieldID + subi.getInput().getType().base().getFieldID(subi.getIndex())};
    update(v, retval);
    return retval;
  })
  .template Case<OpenSubindexOp>([&](auto subi) {
    auto parent = visitValue(subi.getInput(), update);
    PathNode retval{parent.src, parent.fieldID + subi.getInput().getType().getFieldID(subi.getIndex())};
    update(v, retval);
    return retval;
  })
  .template Case<WireOp, RegOp, RegResetOp, InstanceOp, InvalidValueOp>([&](auto def) {
    return PathNode{v, 0};
  })
  .Default([&](auto* op) {
    if (auto ft = type_isa<BundleType, FVectorType, OpenBundleType, OpenVectorType>(v.getType()))
      op->emitError("not handled");
    return PathNode{v, 0};
  });
}

// This only does lookup, due to the const-ness of analysis
FieldSource::PathNode FieldSource::nodeForValue(Value v) const {
  // Blockargs are never cached, just regenerate.
  if (auto arg = dyn_cast<BlockArgument>(v)) {
    return PathNode{v, 0};
  }
  // Check cache.
  auto ii = paths.find(v);
  if (ii != paths.end())
    return ii->second;
  
  //Operation* op = v.getDefiningOp();
  return visitValue(v, [](Value, PathNode){});
}
