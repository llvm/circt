//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements datapath ops.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/Datapath/DatapathOps.h"

using namespace circt;
using namespace datapath;

LogicalResult CompressOp::verify() {
  // The compressor must reduce the number of operands by at least 1 otherwise
  // it fails to perform any reduction.
  if (getNumOperands() < 3)
    return emitOpError("Requires 3 or more arguments - otherwise use add");

  if (getNumResults() >= getNumOperands())
    return emitOpError("Must reduce the number of operands by at least 1");

  if (getNumResults() < 2)
    return emitOpError("Must produce at least 2 results");

  return success();
}

ParseResult CompressOp::parse(OpAsmParser &parser, OperationState &result) {
  SmallVector<OpAsmParser::UnresolvedOperand, 8> operands;

  if (parser.parseOperandList(operands))
    return failure();

  if (parser.parseColon())
    return failure();

  size_t numOperands;
  if (parser.parseInteger(numOperands))
    return failure();

  if (parser.parseKeyword("x"))
    return failure();

  Type operandType;
  if (parser.parseType(operandType))
    return failure();

  // Verify the number of operands
  if (numOperands != operands.size()) {
    return parser.emitError(
        parser.getNameLoc(),
        "number of operands does not match specified count");
  }

  SmallVector<Type, 2> resultTypes;
  if (parser.parseArrow() || parser.parseLParen() ||
      parser.parseTypeList(resultTypes) || parser.parseRParen())
    return failure();

  // Resolve the operands
  SmallVector<Type> operandTypes(operands.size(), operandType);
  if (parser.resolveOperands(operands, operandTypes, parser.getNameLoc(),
                             result.operands))
    return failure();

  result.addTypes(resultTypes);

  return success();
}

// Custom printer for the CompressOp
void CompressOp::print(OpAsmPrinter &p) {
  p << " " << getOperands();
  Type operandType = getOperand(0).getType();
  p << " : " << getNumOperands() << " x " << operandType << " -> (";
  llvm::interleaveComma(getResultTypes(), p);
  p << ")";
}

ParseResult PartialProductOp::parse(OpAsmParser &parser,
                                    OperationState &result) {
  SmallVector<OpAsmParser::UnresolvedOperand, 8> operands;

  if (parser.parseOperandList(operands))
    return failure();

  if (parser.parseColon())
    return failure();

  size_t numResults;
  if (parser.parseInteger(numResults))
    return failure();

  if (parser.parseKeyword("x"))
    return failure();

  Type resultType;
  if (parser.parseType(resultType))
    return failure();

  // Resolve the operands
  SmallVector<Type> operandTypes(operands.size(), resultType);
  if (parser.resolveOperands(operands, operandTypes, parser.getNameLoc(),
                             result.operands))
    return failure();

  SmallVector<Type> resultTypes(numResults, resultType);
  result.addTypes(resultTypes);

  return success();
}

// Custom printer for the PartialProductOp
void PartialProductOp::print(OpAsmPrinter &p) {
  p << " " << getOperands();
  Type resultType = getResult(0).getType();
  p << " : " << getNumResults() << " x " << resultType;
}

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/Datapath/Datapath.cpp.inc"
