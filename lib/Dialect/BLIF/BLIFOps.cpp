//===- BLIFOps.cpp - Implement the BLIF operations ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements BLIF ops.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/BLIF/BLIFOps.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/IR/ImplicitLocOpBuilder.h"

using namespace circt;
using namespace blif;

void ModelOp::build(mlir::OpBuilder &odsBuilder, mlir::OperationState &odsState,
                    StringRef name, ArrayRef<StringRef> inputs,
                    ArrayRef<StringRef> outputs, ArrayRef<StringRef> clocks) {
  SmallVector<hw::ModulePort> modulePorts;
  auto I1 = odsBuilder.getIntegerType(1);
  auto uLoc = odsBuilder.getUnknownLoc();
  auto *r = odsState.addRegion();
  Block *b = new Block();
  r->push_back(b);

  for (auto input : inputs) {
    modulePorts.push_back(
        {odsBuilder.getStringAttr(input), I1, hw::ModulePort::Input});
    b->addArgument(I1, uLoc);
  }
  for (auto output : outputs)
    modulePorts.push_back(
        {odsBuilder.getStringAttr(output), I1, hw::ModulePort::Output});
  for (auto clock : clocks) {
    modulePorts.push_back(
        {odsBuilder.getStringAttr(clock), I1, hw::ModulePort::Input});
    b->addArgument(I1, uLoc);
  }
  auto moduleType = hw::ModuleType::get(odsBuilder.getContext(), modulePorts);
  APInt clockVec(inputs.size() + outputs.size() + clocks.size(), 0);
  for (size_t i = inputs.size() + outputs.size();
       i < inputs.size() + outputs.size() + clocks.size(); i++)
    clockVec.setBit(i);
  auto clockAttr = odsBuilder.getIntegerAttr(
      odsBuilder.getIntegerType(clockVec.getBitWidth()), clockVec);
  odsState.addAttribute("sym_name", odsBuilder.getStringAttr(name));
  odsState.addAttribute("module_type", TypeAttr::get(moduleType));
  odsState.addAttribute("clocks", clockAttr);
}

namespace mlir {
LogicalResult
convertFromAttribute(SmallVectorImpl<int8_t> &storage, Attribute attr,
                     function_ref<InFlightDiagnostic()> emitError) {
  auto valueAttr = dyn_cast<DenseI8ArrayAttr>(attr);
  if (!valueAttr) {
    emitError() << "expected dense array of int8_t for key `value`";
    return failure();
  }
  storage.resize_for_overwrite(valueAttr.size());
  llvm::copy(valueAttr.asArrayRef(), storage.begin());
  return success();
}

Attribute convertToAttribute(MLIRContext *ctx, ArrayRef<int8_t> storage) {
  return DenseI8ArrayAttr::get(ctx, storage);
}

} // namespace mlir

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/BLIF/BLIF.cpp.inc"
