//===- Common.h - Common declarations for the ArcRuntime ------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Declares common structs for the ArcRuntime.
//
// This file belongs to both the public and internal API of the ArcRuntime.
// Changes to the internal API must be reflected in the lowering passes of the
// MLIR model.
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_DIALECT_ARC_RUNTIME_COMMON_H
#define CIRCT_DIALECT_ARC_RUNTIME_COMMON_H

#include <cstring>
#include <stdint.h>

/// Version of the combined public and internal API.
#define ARC_RUNTIME_API_VERSION UINT64_C(0)

/// Magic number used to assert the presence of an `ArcState` struct.
#define ARC_RUNTIME_MAGIC UINT32_C(0xAC1BB1CA)

#pragma pack(push, 1)

// Note: The ArcState struct uses a flexible array member to contain the
// variable-length hardware model state. This adheres to the C99 standard.
// It is not standard C++ but widely supported by C++ compilers, even though
// they might emit a warning.
#if defined(__cplusplus) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc99-extensions"
#endif

/// Combined runtime and model state for a hardware model instance.
struct ArcState {
  /// Runtime implementation specific data. Usually points to a custom struct.
  void *impl;
  /// Padding for alignment and reserved for future use.
  uint32_t reserved;
  /// Runtime magic number. Must be set to `ARC_RUNTIME_MAGIC`.
  uint32_t magic;
  // The model's state.
  uint8_t modelState[];
};

#if defined(__cplusplus) && defined(__clang__)
#pragma clang diagnostic pop
#endif

/// Static information for a compiled hardware model, generated by the
/// MLIR lowering.
struct ArcRuntimeModelInfo {
  /// Runtime API version used when compiling the model.
  uint64_t apiVersion;
  /// Number of bytes required for the model's state.
  uint64_t numStateBytes;
  /// Name of the compiled model.
  const char *modelName;
};

/// A format descriptor, to be given to arcRuntimeFormat.
///
/// arcRuntimeFormat takes an array of FmtDescriptor and a variadic argument
/// list. Each FmtDescriptor describes how to format the corresponding
/// argument. The array is terminated by a FmtDescriptor with action Action_End.
struct FmtDescriptor {
  /// Default construction creates an end of string descriptor.
  FmtDescriptor() {
    std::memset(this, 0, sizeof(*this));
    action = Action_End;
  }

  /// Creates a literal string descriptor.
  ///
  /// width: The width of the literal string in characters.
  ///
  /// The string itself will be passed as a variadic argument (const char*).
  static FmtDescriptor createLiteral(int64_t width) {
    FmtDescriptor d;
    d.action = Action_Literal;
    d.literal.width = width;
    return d;
  }

  /// Creates an integer descriptor.
  ///
  /// bitwidth: The bitwidth of the integer value.
  /// radix: The radix to use for formatting. Must be one of {2, 8, 10, 16}.
  /// isLeftAligned: Whether the value is left aligned.
  /// specifierWidth: The minumum width of the output in characters.
  /// alternative: Whether to use the "alternative" format:
  ///   decimal: Signed if true.
  ///   hex: Uppercase hex letters if true.
  ///
  /// The integer value will be passed as a variadic argument by *pointer*.
  static FmtDescriptor createInt(int32_t bitwidth, int8_t radix,
                                 bool isLeftAligned, int32_t specifierWidth,
                                 bool alternative) {
    FmtDescriptor d;
    d.action = Action_Int;
    d.intFmt.bitwidth = bitwidth;
    d.intFmt.radix = radix;
    d.intFmt.isLeftAligned = isLeftAligned;
    d.intFmt.specifierWidth = specifierWidth;
    d.intFmt.alternative = alternative;
    return d;
  }

  /// Creates a char descriptor.
  ///
  /// The character value will be passed as a variadic argument by value.
  static FmtDescriptor createChar() {
    FmtDescriptor d;
    d.action = Action_Char;
    return d;
  }

  /// The action to take for this descriptor.
  ///
  /// We use uint64_t to ensure that the descriptor is always 16 bytes in size
  /// with zero padding.
  enum Action : uint64_t {
    /// End of the format string, no action to take.
    Action_End = 0,
    /// Prints a literal string.
    Action_Literal,
    /// Prints an integer.
    Action_Int,
    /// Prints a character (%c).
    Action_Char,
  };
  Action action;

  /// Integer formatting options.
  struct IntFmt {
    /// The bitwidth of the integer value.
    int16_t bitwidth;
    /// The minumum width of the output in characters.
    int16_t specifierWidth;
    /// The radix to use for formatting. Must be one of {2, 8, 10, 16}.
    int8_t radix;
    /// Whether the value is left aligned.
    bool isLeftAligned;
    /// Whether to use the "alternative" format:
    ///   decimal: Signed if true.
    ///   hex: Uppercase hex letters if true.
    ///
    /// Unused for all other radix values.
    bool alternative;
  };

  /// Literal string formatting options.
  struct LiteralFmt {
    /// The width of the literal string in characters. Note that the string
    /// itself is passed as a variadic argument, and may contain NUL characters.
    int64_t width;
  };

  union {
    LiteralFmt literal;
    IntFmt intFmt;
  };
};

static_assert(sizeof(FmtDescriptor) == 16, "FmtDescriptor must be 16 bytes");

#pragma pack(pop)

#endif // CIRCT_DIALECT_ARC_RUNTIME_COMMON_H
