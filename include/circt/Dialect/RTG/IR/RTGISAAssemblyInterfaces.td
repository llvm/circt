//===- RTGISAAssemblyInterfaces.td - ISA Assembly RTG ------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_DIALECT_RTG_IR_RTGISAASSEMBLYINTERFACES_TD
#define CIRCT_DIALECT_RTG_IR_RTGISAASSEMBLYINTERFACES_TD

include "mlir/IR/Interfaces.td"
include "mlir/IR/BuiltinAttributeInterfaces.td"

def RegisterAttrInterface : AttrInterface<"RegisterAttrInterface", [TypedAttrInterface]> {
  let description = [{
    This interface should be implemented by attributes that represent
    ISA registers. It is used for elaboration, register allocation, emission,
    etc.
  }];
  let cppNamespace = "::circt::rtg";

  let methods = [
    InterfaceMethod<[{
        Returns the class specific index of the register. This translates from
        the flat internal representation to the architectural representation.
      }],
      "unsigned", "getClassIndex">,
    InterfaceMethod<[{
        Returns a suitable string for use in assembly format.
      }],
      "llvm::StringLiteral", "getRegisterAssembly">,
  ];
}

def RegisterTypeInterface : TypeInterface<"RegisterTypeInterface"> {
  let description = [{
    This interface should be implemented by types that represent
    ISA registers. It is used for elaboration, register allocation, emission,
    etc.
  }];
  let cppNamespace = "::circt::rtg";

  let methods = [
    StaticInterfaceMethod<[{
        Returns the number of registers in the class. Class indices are assumed
        to be a continuous range from 0 
      }],
      "unsigned", "getRegisterClassSize">,
    StaticInterfaceMethod<[{
        Returns the register attribute for the given class-specific index.
        Returns nullptr if the index is out of range.
      }],
      "::circt::rtg::RegisterAttrInterface",
      "getRegisterAttrForClassIndex",
      (ins "::mlir::MLIRContext *":$ctx, "unsigned":$index)>,
  ];
}

//===----------------------------------------------------------------------===//
// Register Effect Decorators
//===----------------------------------------------------------------------===//

// Base class for register effects that can be attached to operands.
// These decorators can be used with the Arg<> wrapper to mark operands.
class RegisterEffect<string effectName> : OpVariableDecorator {
  string effect = effectName;
}

// Marks an operand as a source register (read).
def SourceReg : RegisterEffect<"SourceReg">;
// Marks an operand as a destination register (written).
def DestReg : RegisterEffect<"DestReg">;

//===----------------------------------------------------------------------===//
// RegisterAllocationOpInterface
//===----------------------------------------------------------------------===//

def RegisterAllocationOpInterface : OpInterface<"RegisterAllocationOpInterface"> {
  let description = [{
    This interface should be implemented by operations that read or write
    registers. It is primarily used by the register allocation pass.

    The `isSourceRegister` and `isDestinationRegister` methods are automatically
    generated by the TableGen backend based on operand decorators (`SourceReg`
    and `DestReg`). If no RegisterEffect decorators are present, the interface
    method definitions are not generated and the user is expected to manually
    implement the interface methods.
  }];
  let cppNamespace = "::circt::rtg";

  let methods = [
    InterfaceMethod<[{
        Returns true if the operand at the given index is a source register
        (i.e., it is read by the operation).

        This method is automatically generated by the TableGen backend based on
        SourceReg decorators.
      }],
      "bool", "isSourceRegister", (ins "unsigned":$index)>,
    InterfaceMethod<[{
        Returns true if the operand at the given index is a destination register
        (i.e., it is written by the operation).

        This method is automatically generated by the TableGen backend based on
        DestReg decorators.
      }],
      "bool", "isDestinationRegister", (ins "unsigned":$index)>,
  ];

  let extraClassDeclaration = [{
    /// Returns true if the operand at the given index is both a source and
    /// destination register.
    bool isSourceAndDestinationRegister(unsigned index) {
      return isSourceRegister(index) && isDestinationRegister(index);
    }

    /// Collects all source register operand indices into the provided vector. 
    void getSourceRegisterIndices (::llvm::SmallVectorImpl<unsigned> &indices) {
      for (unsigned i = 0, e = getOperation()->getNumOperands(); i < e; ++i) {
        if (isSourceRegister(i))
          indices.push_back(i);
      }
    }
    
    /// Collects all destination register operand indices into the provided
    /// vector.
    void getDestinationRegisterIndices(
        ::llvm::SmallVectorImpl<unsigned> &indices) {
      for (unsigned i = 0, e = getOperation()->getNumOperands(); i < e; ++i) {
        if (isDestinationRegister(i))
          indices.push_back(i);
      }
    }
  }];
}

def InstructionOpInterface : OpInterface<"InstructionOpInterface", [
  RegisterAllocationOpInterface,
]> {
  let description = [{
    This interface should be implemented by operations that represent
    ISA instructions.
  }];
  let cppNamespace = "::circt::rtg";

  let methods = [
    StaticInterfaceMethod<[{
        Emits a binary representation of the instruction compatible with the
        ISA specification.
      }],
      "void", "printInstructionBinary",
      (ins "llvm::raw_ostream &":$os,
           "llvm::ArrayRef<mlir::Attribute>":$operands)>,
    StaticInterfaceMethod<[{
        Emits the ISA assembly representation of the instruction to the provided
        stream. The format should be the one understood by common assembler
        tools.
      }],
      "void", "printInstructionAssembly",
      (ins "llvm::raw_ostream &":$os,
           "llvm::ArrayRef<mlir::Attribute>":$operands)>,
  ];
}

def InstructionOpAdaptorTrait : NativeOpTrait<"InstructionOpAdaptorTrait"> {
  let extraConcreteClassDeclaration = [{
    static void printInstructionBinary(llvm::raw_ostream &os,
                                       FoldAdaptor adaptor);

    static void printInstructionAssembly(llvm::raw_ostream &os,
                                         FoldAdaptor adaptor);
  }];

  let extraConcreteClassDefinition = [{
    void $cppClass::printInstructionBinary(
        llvm::raw_ostream &os, llvm::ArrayRef<mlir::Attribute> operands) {
      printInstructionBinary(os, FoldAdaptor(operands));
    }

    void $cppClass::printInstructionAssembly(
        llvm::raw_ostream &os, llvm::ArrayRef<mlir::Attribute> operands) {
      printInstructionAssembly(os, FoldAdaptor(operands));
    }
  }];

  let cppNamespace = "::circt::rtg";
}

def InstructionOpAdaptor : TraitList<[
  DeclareOpInterfaceMethods<InstructionOpInterface>,
  DeclareOpInterfaceMethods<RegisterAllocationOpInterface>,
  InstructionOpAdaptorTrait,
]>;

#endif // CIRCT_DIALECT_RTG_IR_RTGISAASSEMBLYINTERFACES_TD
