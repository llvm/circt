//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Generates code and documentation for FIRRTL intrinsics.
//
//===----------------------------------------------------------------------===//

#include "mlir/Support/IndentedOstream.h"
#include "mlir/TableGen/GenInfo.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/TableGen/Record.h"

using namespace llvm;
using namespace mlir;

namespace {
struct IntrinsicDef {
  const Record *def;
  StringRef mnemonic;
  std::string altMnemonic;
  std::string converter;
  StringRef description;

  IntrinsicDef(const Record *def) : def(def) {
    mnemonic = def->getValueAsString("mnemonic");
    description = def->getValueAsOptionalString("description").value_or("");

    // Determine the alternative mnemonic by replacing any unsavory characters
    // with `_`. If that ends up being identical to the original mnemonic, throw
    // it away again.
    altMnemonic = mnemonic;
    for (auto &c : altMnemonic)
      if (!isAlnum(c) && c != '_')
        c = '_';
    if (altMnemonic == mnemonic)
      altMnemonic.clear();

    // Determine the converter name. Default to `<DefName>Converter`.
    if (auto c = def->getValueAsOptionalString("converter")) {
      converter = *c;
    } else {
      converter = def->getName();
      converter += "Converter";
    }
  }
};
} // namespace

static bool emitRegistrations(const RecordKeeper &records, raw_ostream &os) {
  os << "// Autogenerated by circt-tblgen; don't manually edit\n\n";
  os << "static void populateLowerings(IntrinsicLowerings &lowering) {\n";
  for (const auto *def : records.getAllDerivedDefinitions("FIRRTLIntrinsic")) {
    IntrinsicDef intrinsic(def);
    os << "  lowering.add<" << intrinsic.converter << ">(";
    os << '"' << intrinsic.mnemonic << '"';
    if (!intrinsic.altMnemonic.empty())
      os << ", " << '"' << intrinsic.altMnemonic << '"';
    os << ");\n";
  }
  os << "}\n";
  return false;
}

static bool emitDocs(const RecordKeeper &records, raw_ostream &os) {
  os << "<!-- Autogenerated by circt-tblgen; don't manually edit -->\n\n";

  std::vector<IntrinsicDef> intrinsics;
  for (const auto *def : records.getAllDerivedDefinitions("FIRRTLIntrinsic"))
    intrinsics.emplace_back(def);
  sort(intrinsics, [](const IntrinsicDef &a, const IntrinsicDef &b) {
    return a.mnemonic < b.mnemonic;
  });

  for (const auto &intrinsic : intrinsics) {
    os << "### " << intrinsic.mnemonic << "\n\n";
    os << "Mnemonics: ";
    os << "`" << intrinsic.mnemonic << "`";
    if (!intrinsic.altMnemonic.empty())
      os << ", `" << intrinsic.altMnemonic << "`";
    os << "\n\n";
    if (!intrinsic.description.empty()) {
      raw_indented_ostream(os).printReindented(intrinsic.description.rtrim());
      os << "\n\n";
    }
  }

  return false;
}

static GenRegistration
    genRegistration("firrtl-intrinsics",
                    "Generate registration for FIRRTL intrinsics",
                    emitRegistrations);

static GenRegistration genDocs("firrtl-intrinsics-doc",
                               "Generate documentation for FIRRTL intrinsics",
                               emitDocs);
